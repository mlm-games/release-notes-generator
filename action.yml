name: 'release-notes-generator'
description: 'Generate release notes for CHANGELOG.md, version files, and various release platforms'
author: 'mlm-games'

inputs:
  version:
    description: 'Version number (e.g., 1.2.3)'
    required: true
  head-ref:
    description: 'Custom head ref'
    required: false
    default: 'HEAD'
  changelog-path:
    description: 'Path to CHANGELOG.md'
    required: false
    default: 'CHANGELOG.md'
  version-file-path:
    description: 'Path to version file (e.g., fastlane/vercode.txt or changelogs/123.txt)'
    required: false
    default: ''
  version-code:
    description: 'Version code for Android/Fastlane'
    required: false
    default: ''
  metainfo-path:
    description: 'Path to Flathub metainfo.xml file'
    required: false
    default: ''
  format:
    description: 'Line format for each commit. Tokens: {{subject}}, {{author}}, {{committer}}, {{author-email}}, {{committer-email}}, {{author-handle}}, {{committer-handle}}, {{hash}}, {{short-hash}}, {{message}}'
    required: false
    default: '- {{subject}}'
  debug:
    description: 'Print debug info (range, preview)'
    required: false
    default: 'false'
  exclude-patterns:
    description: 'Comma-separated patterns to exclude from subjects (anchored)'
    required: false
    default: 'Update version to,Merge ,Auto-generate changelog'
  vercode-prefix:
    description: 'Prefix before version in CHANGELOG header (e.g., "v")'
    required: false
    default: 'v'
  auto-commit:
    description: 'Automatically commit changes'
    required: false
    default: 'true'
  commit-message:
    description: 'Commit message template'
    required: false
    default: 'Update release notes for v{{version}}'

outputs:
  release-notes:
    description: 'Generated release notes'
  release-name:
    description: 'Release name (latest commit subject)'
  changelog-updated:
    description: 'Whether CHANGELOG.md was updated'
  files-changed:
    description: 'List of files that were changed'

runs:
  using: 'composite'
  steps:
    - name: Generate Release Notes
      id: generate
      shell: bash
      run: |
        set -Eeuo pipefail

        HEAD_REF="${{ inputs.head-ref }}"

        # Compute commit range:
        # - If HEAD is exactly at a tag, use previous tag..HEAD
        # - Else if a latest tag exists, use latest tag..HEAD
        # - Else, use all commits reachable from HEAD (first release)
        LATEST_TAG="$(git describe --tags --abbrev=0 2>/dev/null || true)"
        HEAD_TAG="$(git describe --tags --exact-match "${HEAD_REF}" 2>/dev/null || true)"
        PREV_TAG=""
        if [ -n "$HEAD_TAG" ]; then
          PREV_TAG="$(git describe --tags --abbrev=0 --exclude="$HEAD_TAG" 2>/dev/null || true)"
        fi

        if [ -n "$HEAD_TAG" ] && [ -n "$PREV_TAG" ]; then
          RANGE="${PREV_TAG}..${HEAD_REF}"
        elif [ -z "$HEAD_TAG" ] && [ -n "$LATEST_TAG" ]; then
          RANGE="${LATEST_TAG}..${HEAD_REF}"
        else
          RANGE="${HEAD_REF}"
        fi

        # Build anchored, regex-safe exclusion regex from comma-separated list (applies to subject)
        RAW="${{ inputs.exclude-patterns }}"
        IFS=',' read -ra EX_PATTERNS <<< "$RAW"
        EX_REGEX=""
        for p in "${EX_PATTERNS[@]}"; do
          p="$(echo "$p" | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
          [ -z "$p" ] && continue
          ep="$(printf '%s' "$p" | sed -E 's/[][(){}.^$*+?|\\/]/\\&/g')"
          ep="^${ep}"
          EX_REGEX="${EX_REGEX:+${EX_REGEX}|}${ep}"
        done

        # Helper: derive a GitHub-like handle from name/email (e.g., 12345+user@users.noreply.github.com -> user)
        gh_handle() {
          local name="$1" email="$2" lp handle=""
          if [[ "$email" =~ ^([^@]+)@users\.noreply\.github\.com$ ]]; then
            lp="${BASH_REMATCH[1]}"
            if [[ "$lp" == *"+"* ]]; then
              handle="${lp#*+}"
            else
              handle="$lp"
            fi
          fi
          # Fallback if name looks like a handle or a bot name
          if [ -z "$handle" ] && [[ "$name" =~ ^[A-Za-z0-9][A-Za-z0-9-]{0,38}(\[bot\])?$ ]]; then
            handle="${name%\[bot\]}"
          fi
          printf '%s' "$handle"
        }

        RELEASE_NOTES=""
        RELEASE_NAME=""

        # Robust record parsing using ASCII unit/record separators to avoid NUL-in-variable issues.
        # Record: subject ␟ author ␟ author_email ␟ committer ␟ committer_email ␟ hash ␟ short ␟ body ␞
        sep_f=$'\x1f'
        sep_r=$'\x1e'
        exec 3< <(git log -z --no-merges ${RANGE} \
          --pretty=format:"%s%x1f%an%x1f%ae%x1f%cn%x1f%ce%x1f%H%x1f%h%x1f%b%x1e")

        while IFS= read -r -d "$sep_r" rec <&3; do
          IFS="$sep_f" read -r subject author author_email committer committer_email hash short body <<< "$rec"

          # Exclude by anchored subject
          if [ -n "$EX_REGEX" ] && printf '%s' "$subject" | grep -Eq "$EX_REGEX"; then
            continue
          fi

          # Normalize fields
          subject="$(printf '%s' "$subject" | tr -d '\r' | sed -E 's/[[:space:]]+$//')"
          body="$(printf '%s' "$body" | tr '\r\n' ' ' | sed -E 's/[[:space:]]+/ /g; s/[[:space:]]+$//')"
          msg="$(printf '%s %s' "$subject" "$body" | sed -E 's/[[:space:]]+/ /g; s/[[:space:]]+$//')"

          author_handle="$(gh_handle "$author" "$author_email")"
          committer_handle="$(gh_handle "$committer" "$committer_email")"

          tpl='${{ inputs.format }}'

          # First pass: direct token replacements
          tpl="${tpl//\{\{subject\}\}/$subject}"
          tpl="${tpl//\{\{author\}\}/$author}"
          tpl="${tpl//\{\{committer\}\}/$committer}"
          tpl="${tpl//\{\{author-email\}\}/$author_email}"
          tpl="${tpl//\{\{committer-email\}\}/$committer_email}"
          tpl="${tpl//\{\{author-handle\}\}/$author_handle}"
          tpl="${tpl//\{\{committer-handle\}\}/$committer_handle}"
          tpl="${tpl//\{\{hash\}\}/$hash}"
          tpl="${tpl//\{\{short-hash\}\}/$short}"
          tpl="${tpl//\{\{short\}\}/$short}"
          tpl="${tpl//\{\{message\}\}/$msg}"

          # Second pass: fallbacks like {{author-handle|committer-handle}}
          # Only recognized tokens are substituted; unknown tokens become empty.
          while [[ "$tpl" =~ \{\{([^}]+)\}\} ]]; do
            raw="${BASH_REMATCH[1]}"
            repl=""
            IFS='|' read -ra parts <<< "$raw"
            for part in "${parts[@]}"; do
              case "$part" in
                subject)            repl="$subject" ;;
                author)             repl="$author" ;;
                committer)          repl="$committer" ;;
                author-email)       repl="$author_email" ;;
                committer-email)    repl="$committer_email" ;;
                author-handle)      repl="$author_handle" ;;
                committer-handle)   repl="$committer_handle" ;;
                hash)               repl="$hash" ;;
                short|short-hash)   repl="$short" ;;
                message)            repl="$msg" ;;
                *)                  ;;  # ignore unknowns
              esac
              [ -n "$repl" ] && break
            done
            tpl="${tpl/${BASH_REMATCH[0]}/$repl}"
          done

          # Cleanup: collapse spaces and remove dangling "by @" fragments if handle was empty
          tpl="$(printf '%s' "$tpl" \
                | sed -E 's/[[:space:]]+/ /g; s/^[[:space:]]+|[[:space:]]+$//g' \
                | sed -E 's/[[:space:]]+by[[:space:]]+@$//; s/@$//')"

          # If the user forgot a bullet, keep consistent bullets
          if ! printf '%s' "$tpl" | grep -qE '^[*-] '; then
            tpl="- $tpl"
          fi

          [ -n "$tpl" ] && RELEASE_NOTES+="${tpl}"$'\n'
          [ -z "$RELEASE_NAME" ] && RELEASE_NAME="$subject"
        done
        exec 3<&-

        # Trim trailing newline
        RELEASE_NOTES="${RELEASE_NOTES%$'\n'}"

        if [ "${{ inputs.debug }}" = "true" ]; then
          echo "Latest tag: ${LATEST_TAG}"
          echo "Head ref: ${HEAD_REF}"
          echo "Head tag: ${HEAD_TAG}"
          echo "Prev tag: ${PREV_TAG}"
          echo "Range: ${RANGE}"
          echo "Exclude regex: ${EX_REGEX:-<none>}"
          echo "Preview:"
          printf '%s\n' "$RELEASE_NOTES" | head -20
        fi

        # Output through GITHUB_OUTPUT (safe custom delimiter)
        DELIM="END_OF_RELEASE_NOTES_$(date +%s%N)_$RANDOM"
        {
          printf 'release-notes<<%s\n' "$DELIM"
          printf '%s\n' "$RELEASE_NOTES"
          printf '%s\n' "$DELIM"
          printf 'release-name=%s\n' "$RELEASE_NAME"
        } >> "$GITHUB_OUTPUT"

        # Save to file for later steps
        printf '%s\n' "$RELEASE_NOTES" > /tmp/release-notes.txt

    - name: Update CHANGELOG.md
      if: inputs.changelog-path != ''
      id: changelog
      shell: bash
      run: |
        set -Eeuo pipefail
        CHANGELOG_PATH="${{ inputs.changelog-path }}"
        VERSION="${{ inputs.version }}"
        PREFIX="${{ inputs.vercode-prefix }}"
        HEADER_LINE="## ${PREFIX}${VERSION}"
        UPDATED="false"

        write_notes() {
          if [ -s /tmp/release-notes.txt ]; then
            cat /tmp/release-notes.txt
          else
            echo "- No changes since previous release"
          fi
        }

        if [ -f "$CHANGELOG_PATH" ]; then
          if grep -Fq "$HEADER_LINE" "$CHANGELOG_PATH"; then
            echo "Version already present: $HEADER_LINE"
          else
            {
              echo "$HEADER_LINE"
              echo ""
              write_notes
              echo ""
              echo ""
              cat "$CHANGELOG_PATH"
            } > /tmp/new-changelog.md
            mv /tmp/new-changelog.md "$CHANGELOG_PATH"
            UPDATED="true"
            echo "Updated ${CHANGELOG_PATH}"
          fi
        else
          {
            echo "# Changelog"
            echo ""
            echo "$HEADER_LINE"
            echo ""
            write_notes
            echo ""
          } > "$CHANGELOG_PATH"
          UPDATED="true"
          echo "Created ${CHANGELOG_PATH}"
        fi

        echo "changelog-updated=$UPDATED" >> "$GITHUB_OUTPUT"

    - name: Update Version File
      if: inputs.version-file-path != '' && inputs.version-code != ''
      shell: bash
      run: |
        set -Eeuo pipefail
        VERSION_FILE="${{ inputs.version-file-path }}"
        VERSION_CODE="${{ inputs.version-code }}"
        mkdir -p "$(dirname "$VERSION_FILE")"

        if [[ "$VERSION_FILE" == *"/changelogs/"* ]]; then
          # Per-build Fastlane-style changelog
          cat /tmp/release-notes.txt > "$VERSION_FILE"
        else
          echo "$VERSION_CODE" > "$VERSION_FILE"
        fi
        echo "Updated version file: $VERSION_FILE"

    - name: Update Flathub Metainfo
      if: inputs.metainfo-path != ''
      shell: bash
      run: |
        set -Eeuo pipefail
    
        METAINFO="${{ inputs.metainfo-path }}"
        VERSION="${{ inputs.version }}"
        DATE="$(date +%F)"          # 2025-11-01
        NOTES=/tmp/release-notes.txt
    
        if [ ! -f "$METAINFO" ]; then
          echo "::warning::metainfo not found: $METAINFO"
          exit 0
        fi
    
        # Stop if the same version is already present
        if xmlstarlet sel -t -v "/component/releases/release[@version='${VERSION}']" "$METAINFO" \
           | grep -q . ; then
          echo "Version $VERSION already listed – skipping"
          exit 0
        fi
    
        # 1.  Create an *empty* <release/> as the new first child
        #     of <releases>.  If no <release> exists yet, we simply append.
        if xmlstarlet sel -t -c '/component/releases/release[1]' "$METAINFO" | grep -q . ; then
          # There is at least one existing release → insert *before* it
          xmlstarlet ed -L \
            --insert '/component/releases/release[1]' --type elem -n release -v '' \
            "$METAINFO"
        else
          # No <release> yet → just create the node
          xmlstarlet ed -L \
            --subnode '/component/releases'          --type elem -n release -v '' \
            "$METAINFO"
        fi
    
        # 2.  Add mandatory attributes to that first <release>
        xmlstarlet ed -L \
          --insert '/component/releases/release[1]' --type attr -n version -v "$VERSION" \
          --insert '/component/releases/release[1]' --type attr -n date    -v "$DATE" \
          --insert '/component/releases/release[1]' --type attr -n type    -v "stable" \
          "$METAINFO"
    
        # 3.  Build the description list
        xmlstarlet ed -L \
          --subnode '/component/releases/release[1]'            --type elem -n description -v '' \
          --subnode '/component/releases/release[1]/description' --type elem -n ul          -v '' \
          "$METAINFO"
    
        if [ -s "$NOTES" ]; then
          while IFS= read -r line; do
            line="${line#- }"                               # strip leading "- "
            xmlstarlet ed -L \
              --subnode '/component/releases/release[1]/description/ul' \
              --type elem -n li -v "$(xmlstarlet esc <<<"$line")" \
              "$METAINFO"
          done < "$NOTES"
        else
          xmlstarlet ed -L \
            --subnode '/component/releases/release[1]/description/ul' \
            --type elem -n li -v "No changes since previous release" \
            "$METAINFO"
        fi
    
        echo "Metainfo updated: $METAINFO"
        
    - name: Collect Changed Files
      id: files
      shell: bash
      run: |
        set -Eeuo pipefail
        CHANGED_FILES=""

        if [ "${{ steps.changelog.outputs.changelog-updated }}" = "true" ]; then
          CHANGED_FILES="${{ inputs.changelog-path }}"
        fi

        if [ -n "${{ inputs.version-file-path }}" ] && [ -n "${{ inputs.version-code }}" ]; then
          if [ -n "$CHANGED_FILES" ]; then
            CHANGED_FILES="$CHANGED_FILES,${{ inputs.version-file-path }}"
          else
            CHANGED_FILES="${{ inputs.version-file-path }}"
          fi
        fi

        if [ -n "${{ inputs.metainfo-path }}" ] && [ -f "${{ inputs.metainfo-path }}" ]; then
          if [ -n "$CHANGED_FILES" ]; then
            CHANGED_FILES="$CHANGED_FILES,${{ inputs.metainfo-path }}"
          else
            CHANGED_FILES="${{ inputs.metainfo-path }}"
          fi
        fi

        echo "files-changed=$CHANGED_FILES" >> "$GITHUB_OUTPUT"

    - name: Commit Changes
      if: inputs.auto-commit == 'true' && steps.files.outputs.files-changed != ''
      shell: bash
      run: |
        set -Eeuo pipefail
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Actions"

        IFS=',' read -ra FILES <<< "${{ steps.files.outputs.files-changed }}"
        for file in "${FILES[@]}"; do
          if [ -f "$file" ]; then
            git add "$file"
          fi
        done

        COMMIT_MSG="${{ inputs.commit-message }}"
        COMMIT_MSG="${COMMIT_MSG//\{\{version\}\}/${{ inputs.version }}}"

        git commit -m "$COMMIT_MSG" || echo "No changes to commit"
        git push || echo "Nothing to push"

branding:
  icon: 'file-text'
  color: 'blue'
